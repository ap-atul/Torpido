<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>lib.util.ffmpegTools API documentation</title>
<meta name="description" content="Utility functions to run subprocess with generated FFmpeg queries.
Function to build the commands live here." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lib.util.ffmpegTools</code></h1>
</header>
<section id="section-intro">
<p>Utility functions to run subprocess with generated FFmpeg queries.
Function to build the commands live here.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Utility functions to run subprocess with generated FFmpeg queries.
Function to build the commands live here.
&#34;&#34;&#34;

import subprocess

from lib.util.logger import Log


def buildSplitCommand(inputFile, outputAudioFile):
    &#34;&#34;&#34;
    Creates a list for each bit of the command line to run
    since it is a list the command line is secure and can
    run with file names that are not formatted correctly.
    or doesn&#39;t need any explicit formatting.

    Parameters
    ----------
    inputFile : str
        input video file name and path
    outputAudioFile : str
        output audio file name and path

    Returns
    ---------
    _CMD
        command line to pass to the subprocess

    Examples
    ----------
    The command created spits the video file into an audio file, The file paths
    are kept same. The command goes like this

    `ffmpeg -y -i input.mkv output.wav`

        &#39;-y&#39; : FFmpeg option for &#39;yes override&#39;. Override the output file it exists
        &#39;-i&#39; : FFmpeg option for &#39;input file&#39;. Input file can be multiple

    &#34;&#34;&#34;
    return [
        &#39;ffmpeg&#39;,
        &#39;-y&#39;,
        &#39;-i&#39;,
        str(inputFile),
        str(outputAudioFile)
    ]


def split(inputFile, outputAudioFile):
    &#34;&#34;&#34;
    Splits the input video file into audio for Audio Processing.

    Helper function to run the generated command line with subprocess the stdout log is yielded to generate
    the progress bar. Look into `io` for details

    Parameters
    ----------
    inputFile : str
        name of the input video file
    outputAudioFile : str
        name of the output audio file

    Yields
    -------
    str
        yields std out logs in string
    &#34;&#34;&#34;
    command = buildSplitCommand(inputFile, outputAudioFile)
    run = subprocess.Popen(args=command,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.STDOUT,
                           universal_newlines=True)
    for stdout in iter(run.stdout.readline, &#34;&#34;):
        yield stdout

    run.stdout.close()
    if run.wait():
        Log.e(&#34;The splitting process has caused an error.&#34;)
        return None


def buildMergeCommand(videoFile, audioFile, outputFile, timestamps):
    &#34;&#34;&#34;
    Building a complex filter
    command line to clip portions based on the timestamps, the copies used
    to trim some portion depend on the length of the timestamps since that
    will define the number of the trims

    Parameters
    ----------
    videoFile : str
        original input video file
    audioFile : str
        processed audio file (de-noised)
    outputFile : str
        final output video file edited by Torpido
    timestamps : iterable
        start and end timestamps of the video clips to trim

    Returns
    -------
    str
        generated string from the complex filter built

    Examples
    --------
    The command line has following structure

    `
    ffmpeg -y -i input.mkv -i input.wav -filter_complex
    &#34;[0:v]split=2[vc1][vc2];
    [vc1]trim=start=304:duration=10.567,setpts=PTS-STARTPTS[v1];
    [vc2]trim=start=100:duration=10.789,setpts=PTS-STARTPTS[v2];
    [1:a]asplit=2[ac1][ac2];
    [ac1]atrim=start=0:duration=10.123,asetpts=PTS-STARTPTS[a1];
    [ac2]atrim=start=304:duration=10,asetpts=PTS-STARTPTS[a2];
    [v1][a1][v2][a2]concat=n=2:v=1:a=1[video][audio]&#34;
    -map &#34;[video]&#34; -map &#34;[audio]&#34; output_new.mkv
    `

        &#39;-y&#39; :              FFmpeg option for &#39;yes override&#39;. Override the output file it exists
        &#39;-i&#39; :              FFmpeg option for &#39;input file&#39;. Input file to the command can be multiple
        &#39;-filter_complex&#39; : create a complex filter
        &#39;split&#39; :           split option of filter to split the video stream into n ; here n=2
        &#39;trim&#39; :            trim option of filter to trim the video stream with
                            start= and duration=, also setpts:presentation points
        &#39;asplit&#39; :          audio stream split
        &#39;atrim&#39; :           audio stream trim
        &#39;concat&#39; :          concatenate input stream to output v=1:a=1 one video and one audio streams
        &#39;map&#39; :             map the labels of stream to the output file
        &#39;[]&#39; :              labels for each stream

    &#34;&#34;&#34;
    filterString = &#39;ffmpeg&#39; + \
                   &#39; -y&#39; + \
                   &#39; -i &#39; + \
                   str(videoFile) + \
                   &#39; -i &#39; + \
                   str(audioFile) + \
                   &#39; -filter_complex &#39; + \
                   &#39;&#34;[0:v]split=&#39; + str(len(timestamps))

    for i in range(len(timestamps)):
        filterString += &#39;[vc%d]&#39; % i
    filterString += &#39;; &#39;

    for i in range(len(timestamps)):
        startTime = timestamps[i][0]
        endTime = timestamps[i][1]
        filterString += &#39;[vc%d]&#39; % i
        filterString += &#39;trim=start=%f:duration=%f,setpts=PTS-STARTPTS[v%d]; &#39; \
                        % (startTime, (endTime - startTime), int(i))

    filterString += &#39;[1:a]asplit=&#39; + str(len(timestamps))
    for i in range(len(timestamps)):
        filterString += &#39;[ac%d]&#39; % i
    filterString += &#39;; &#39;

    for i in range(len(timestamps)):
        startTime = timestamps[i][0]
        endTime = timestamps[i][1]
        filterString += &#39;[ac%d]&#39; % i
        filterString += &#39;atrim=start=%f:duration=%f,asetpts=PTS-STARTPTS[a%d]; &#39; \
                        % (startTime, (endTime - startTime), int(i))

    for i in range(len(timestamps)):
        filterString += &#39;[v%d][a%d]&#39; % (i, i)
    filterString += &#39;concat=n=%d:v=1:a=1[video][audio]&#34;&#39; % (len(timestamps))

    filterString += &#39; -map&#39; + \
                    &#39; &#34;[video]&#34;&#39; + \
                    &#39; -map&#39; + \
                    &#39; &#34;[audio]&#34; &#39; + \
                    str(outputFile)

    return filterString


def merge(videoFile, audioFile, outputFile, timestamps):
    &#34;&#34;&#34;
    Generate the command for complex filter according to the timestamps and encode the output video. Merge the
    input video file and replace the audio stream with the de-noised audio stream

    Notes
    ------
    For using `string` as a command line it is very necessary to add shell=True in the Popen
    function argument or it won&#39;t work

    Use `stderr=subprocess.STDOUT` to stop printing the command output even though nothing
    is printing

    Parameters
    ----------
    videoFile : str
        input video file
    audioFile : str
        de-noised audio file
    outputFile : str
        final output video file
    timestamps : list
        list of clip time stamps with start and end times

    Yields
    -------
    str
        continous std out logs
    &#34;&#34;&#34;
    # print(f&#34;[TIMESTAMPS] time stamps : {timestamps}&#34;)
    command = buildMergeCommand(videoFile, audioFile, outputFile, timestamps)
    # print(command)
    run = subprocess.Popen(args=command,
                           shell=True,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.STDOUT,
                           universal_newlines=True)
    for stdout in iter(run.stdout.readline, &#34;&#34;):
        yield stdout

    run.stdout.close()
    if run.wait():
        Log.e(f&#34;The merging process has caused an error.&#34;)
        return None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="lib.util.ffmpegTools.buildMergeCommand"><code class="name flex">
<span>def <span class="ident">buildMergeCommand</span></span>(<span>videoFile, audioFile, outputFile, timestamps)</span>
</code></dt>
<dd>
<div class="desc"><p>Building a complex filter
command line to clip portions based on the timestamps, the copies used
to trim some portion depend on the length of the timestamps since that
will define the number of the trims</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>videoFile</code></strong> :&ensp;<code>str</code></dt>
<dd>original input video file</dd>
<dt><strong><code>audioFile</code></strong> :&ensp;<code>str</code></dt>
<dd>processed audio file (de-noised)</dd>
<dt><strong><code>outputFile</code></strong> :&ensp;<code>str</code></dt>
<dd>final output video file edited by Torpido</dd>
<dt><strong><code>timestamps</code></strong> :&ensp;<code>iterable</code></dt>
<dd>start and end timestamps of the video clips to trim</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>generated string from the complex filter built</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>The command line has following structure</p>
<p><code>ffmpeg -y -i input.mkv -i input.wav -filter_complex
"[0:v]split=2[vc1][vc2];
[vc1]trim=start=304:duration=10.567,setpts=PTS-STARTPTS[v1];
[vc2]trim=start=100:duration=10.789,setpts=PTS-STARTPTS[v2];
[1:a]asplit=2[ac1][ac2];
[ac1]atrim=start=0:duration=10.123,asetpts=PTS-STARTPTS[a1];
[ac2]atrim=start=304:duration=10,asetpts=PTS-STARTPTS[a2];
[v1][a1][v2][a2]concat=n=2:v=1:a=1[video][audio]"
-map "[video]" -map "[audio]" output_new.mkv</code></p>
<pre><code>'-y' :              FFmpeg option for 'yes override'. Override the output file it exists
'-i' :              FFmpeg option for 'input file'. Input file to the command can be multiple
'-filter_complex' : create a complex filter
'split' :           split option of filter to split the video stream into n ; here n=2
'trim' :            trim option of filter to trim the video stream with
                    start= and duration=, also setpts:presentation points
'asplit' :          audio stream split
'atrim' :           audio stream trim
'concat' :          concatenate input stream to output v=1:a=1 one video and one audio streams
'map' :             map the labels of stream to the output file
'[]' :              labels for each stream
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildMergeCommand(videoFile, audioFile, outputFile, timestamps):
    &#34;&#34;&#34;
    Building a complex filter
    command line to clip portions based on the timestamps, the copies used
    to trim some portion depend on the length of the timestamps since that
    will define the number of the trims

    Parameters
    ----------
    videoFile : str
        original input video file
    audioFile : str
        processed audio file (de-noised)
    outputFile : str
        final output video file edited by Torpido
    timestamps : iterable
        start and end timestamps of the video clips to trim

    Returns
    -------
    str
        generated string from the complex filter built

    Examples
    --------
    The command line has following structure

    `
    ffmpeg -y -i input.mkv -i input.wav -filter_complex
    &#34;[0:v]split=2[vc1][vc2];
    [vc1]trim=start=304:duration=10.567,setpts=PTS-STARTPTS[v1];
    [vc2]trim=start=100:duration=10.789,setpts=PTS-STARTPTS[v2];
    [1:a]asplit=2[ac1][ac2];
    [ac1]atrim=start=0:duration=10.123,asetpts=PTS-STARTPTS[a1];
    [ac2]atrim=start=304:duration=10,asetpts=PTS-STARTPTS[a2];
    [v1][a1][v2][a2]concat=n=2:v=1:a=1[video][audio]&#34;
    -map &#34;[video]&#34; -map &#34;[audio]&#34; output_new.mkv
    `

        &#39;-y&#39; :              FFmpeg option for &#39;yes override&#39;. Override the output file it exists
        &#39;-i&#39; :              FFmpeg option for &#39;input file&#39;. Input file to the command can be multiple
        &#39;-filter_complex&#39; : create a complex filter
        &#39;split&#39; :           split option of filter to split the video stream into n ; here n=2
        &#39;trim&#39; :            trim option of filter to trim the video stream with
                            start= and duration=, also setpts:presentation points
        &#39;asplit&#39; :          audio stream split
        &#39;atrim&#39; :           audio stream trim
        &#39;concat&#39; :          concatenate input stream to output v=1:a=1 one video and one audio streams
        &#39;map&#39; :             map the labels of stream to the output file
        &#39;[]&#39; :              labels for each stream

    &#34;&#34;&#34;
    filterString = &#39;ffmpeg&#39; + \
                   &#39; -y&#39; + \
                   &#39; -i &#39; + \
                   str(videoFile) + \
                   &#39; -i &#39; + \
                   str(audioFile) + \
                   &#39; -filter_complex &#39; + \
                   &#39;&#34;[0:v]split=&#39; + str(len(timestamps))

    for i in range(len(timestamps)):
        filterString += &#39;[vc%d]&#39; % i
    filterString += &#39;; &#39;

    for i in range(len(timestamps)):
        startTime = timestamps[i][0]
        endTime = timestamps[i][1]
        filterString += &#39;[vc%d]&#39; % i
        filterString += &#39;trim=start=%f:duration=%f,setpts=PTS-STARTPTS[v%d]; &#39; \
                        % (startTime, (endTime - startTime), int(i))

    filterString += &#39;[1:a]asplit=&#39; + str(len(timestamps))
    for i in range(len(timestamps)):
        filterString += &#39;[ac%d]&#39; % i
    filterString += &#39;; &#39;

    for i in range(len(timestamps)):
        startTime = timestamps[i][0]
        endTime = timestamps[i][1]
        filterString += &#39;[ac%d]&#39; % i
        filterString += &#39;atrim=start=%f:duration=%f,asetpts=PTS-STARTPTS[a%d]; &#39; \
                        % (startTime, (endTime - startTime), int(i))

    for i in range(len(timestamps)):
        filterString += &#39;[v%d][a%d]&#39; % (i, i)
    filterString += &#39;concat=n=%d:v=1:a=1[video][audio]&#34;&#39; % (len(timestamps))

    filterString += &#39; -map&#39; + \
                    &#39; &#34;[video]&#34;&#39; + \
                    &#39; -map&#39; + \
                    &#39; &#34;[audio]&#34; &#39; + \
                    str(outputFile)

    return filterString</code></pre>
</details>
</dd>
<dt id="lib.util.ffmpegTools.buildSplitCommand"><code class="name flex">
<span>def <span class="ident">buildSplitCommand</span></span>(<span>inputFile, outputAudioFile)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a list for each bit of the command line to run
since it is a list the command line is secure and can
run with file names that are not formatted correctly.
or doesn't need any explicit formatting.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inputFile</code></strong> :&ensp;<code>str</code></dt>
<dd>input video file name and path</dd>
<dt><strong><code>outputAudioFile</code></strong> :&ensp;<code>str</code></dt>
<dd>output audio file name and path</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_CMD</code></dt>
<dd>command line to pass to the subprocess</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>The command created spits the video file into an audio file, The file paths
are kept same. The command goes like this</p>
<p><code>ffmpeg -y -i input.mkv output.wav</code></p>
<pre><code>'-y' : FFmpeg option for 'yes override'. Override the output file it exists
'-i' : FFmpeg option for 'input file'. Input file can be multiple
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildSplitCommand(inputFile, outputAudioFile):
    &#34;&#34;&#34;
    Creates a list for each bit of the command line to run
    since it is a list the command line is secure and can
    run with file names that are not formatted correctly.
    or doesn&#39;t need any explicit formatting.

    Parameters
    ----------
    inputFile : str
        input video file name and path
    outputAudioFile : str
        output audio file name and path

    Returns
    ---------
    _CMD
        command line to pass to the subprocess

    Examples
    ----------
    The command created spits the video file into an audio file, The file paths
    are kept same. The command goes like this

    `ffmpeg -y -i input.mkv output.wav`

        &#39;-y&#39; : FFmpeg option for &#39;yes override&#39;. Override the output file it exists
        &#39;-i&#39; : FFmpeg option for &#39;input file&#39;. Input file can be multiple

    &#34;&#34;&#34;
    return [
        &#39;ffmpeg&#39;,
        &#39;-y&#39;,
        &#39;-i&#39;,
        str(inputFile),
        str(outputAudioFile)
    ]</code></pre>
</details>
</dd>
<dt id="lib.util.ffmpegTools.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>videoFile, audioFile, outputFile, timestamps)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the command for complex filter according to the timestamps and encode the output video. Merge the
input video file and replace the audio stream with the de-noised audio stream</p>
<h2 id="notes">Notes</h2>
<p>For using <code>string</code> as a command line it is very necessary to add shell=True in the Popen
function argument or it won't work</p>
<p>Use <code>stderr=subprocess.STDOUT</code> to stop printing the command output even though nothing
is printing</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>videoFile</code></strong> :&ensp;<code>str</code></dt>
<dd>input video file</dd>
<dt><strong><code>audioFile</code></strong> :&ensp;<code>str</code></dt>
<dd>de-noised audio file</dd>
<dt><strong><code>outputFile</code></strong> :&ensp;<code>str</code></dt>
<dd>final output video file</dd>
<dt><strong><code>timestamps</code></strong> :&ensp;<code>list</code></dt>
<dd>list of clip time stamps with start and end times</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>str</code></dt>
<dd>continous std out logs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(videoFile, audioFile, outputFile, timestamps):
    &#34;&#34;&#34;
    Generate the command for complex filter according to the timestamps and encode the output video. Merge the
    input video file and replace the audio stream with the de-noised audio stream

    Notes
    ------
    For using `string` as a command line it is very necessary to add shell=True in the Popen
    function argument or it won&#39;t work

    Use `stderr=subprocess.STDOUT` to stop printing the command output even though nothing
    is printing

    Parameters
    ----------
    videoFile : str
        input video file
    audioFile : str
        de-noised audio file
    outputFile : str
        final output video file
    timestamps : list
        list of clip time stamps with start and end times

    Yields
    -------
    str
        continous std out logs
    &#34;&#34;&#34;
    # print(f&#34;[TIMESTAMPS] time stamps : {timestamps}&#34;)
    command = buildMergeCommand(videoFile, audioFile, outputFile, timestamps)
    # print(command)
    run = subprocess.Popen(args=command,
                           shell=True,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.STDOUT,
                           universal_newlines=True)
    for stdout in iter(run.stdout.readline, &#34;&#34;):
        yield stdout

    run.stdout.close()
    if run.wait():
        Log.e(f&#34;The merging process has caused an error.&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="lib.util.ffmpegTools.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>inputFile, outputAudioFile)</span>
</code></dt>
<dd>
<div class="desc"><p>Splits the input video file into audio for Audio Processing.</p>
<p>Helper function to run the generated command line with subprocess the stdout log is yielded to generate
the progress bar. Look into <code>io</code> for details</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inputFile</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the input video file</dd>
<dt><strong><code>outputAudioFile</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the output audio file</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>str</code></dt>
<dd>yields std out logs in string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(inputFile, outputAudioFile):
    &#34;&#34;&#34;
    Splits the input video file into audio for Audio Processing.

    Helper function to run the generated command line with subprocess the stdout log is yielded to generate
    the progress bar. Look into `io` for details

    Parameters
    ----------
    inputFile : str
        name of the input video file
    outputAudioFile : str
        name of the output audio file

    Yields
    -------
    str
        yields std out logs in string
    &#34;&#34;&#34;
    command = buildSplitCommand(inputFile, outputAudioFile)
    run = subprocess.Popen(args=command,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.STDOUT,
                           universal_newlines=True)
    for stdout in iter(run.stdout.readline, &#34;&#34;):
        yield stdout

    run.stdout.close()
    if run.wait():
        Log.e(&#34;The splitting process has caused an error.&#34;)
        return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lib.util" href="index.html">lib.util</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="lib.util.ffmpegTools.buildMergeCommand" href="#lib.util.ffmpegTools.buildMergeCommand">buildMergeCommand</a></code></li>
<li><code><a title="lib.util.ffmpegTools.buildSplitCommand" href="#lib.util.ffmpegTools.buildSplitCommand">buildSplitCommand</a></code></li>
<li><code><a title="lib.util.ffmpegTools.merge" href="#lib.util.ffmpegTools.merge">merge</a></code></li>
<li><code><a title="lib.util.ffmpegTools.split" href="#lib.util.ffmpegTools.split">split</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>